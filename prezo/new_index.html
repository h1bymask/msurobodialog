<html>
	<head>
		<meta charset="utf-8">
		<style type="text/css">
			    object, img { 
					position: absolute; 
					left: 0; 
					height: 100%; 
					width: 100%; 
				}
				body {
					overflow-y: hidden;
				}
		</style>
		<!--<script src="https://cdn.jsdelivr.net/npm/brython@3/brython.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/brython@3/brython_stdlib.js"></script>-->
		<script src="brython-3.10.5.min.js"></script>
		<script src="brython_stdlib-3.10.5.js"></script>
	</head>
	<body>		
		<script type="text/javascript">
			let body = document.getElementsByTagName("body")[0];
			let img = document.createElement("img");  //("object");
			let articulation_img = document.createElement("img");  //("object");
			let key_pressed_earlier = "";
			let svg_in_progress = null;
			let playback_in_progress = null;
			let articulation_in_progress = null;
			let	key_subscriptions = new Map();
			let cache = new Map();
			document.addEventListener("keypress", (keyboardEvent) => {
				let key = keyboardEvent.code;
				if (key_subscriptions.has(key))
					document.dispatchEvent(key_subscriptions.get(key));
			});
			async function timeout(ms) {
				return new Promise(resolve => setTimeout(resolve, ms));
			}
			img.type = "image/svg+xml";
			articulation_img.type = "image/svg+xml";
			for (let tag of body.children)
				if (tag.tagName.toLowerCase() != "script")
					body.removeChild(tag);
			body.appendChild(img);
			body.appendChild(articulation_img);
			function slide(src) {
				console.log("Showing " + src + " slide");
				img.src = cache.has(src) ? cache.get(src) : src;
			}
			current_slide = () => (img||{}).src||'';
			async function articulation(ms, src) {  // Usage: await window.articulation()
				if (articulation_in_progress != null) {
					await articulation_in_progress;
					articulation_in_progress = null;
				}
				//console.log("Setting articulation to " + src + " for " + ms + " ms");
				articulation_img.src = cache.has(src) ? cache.get(src) : src;
				duration = ms;
				if (duration != null && ms >= 1)
					articulation_in_progress = timeout(duration);
			}
			async function articulation2(src) {  // TODO
				if (svg_in_progress != null) {
					let progress = svg_in_progress;
					svg_in_progress = null;
					await progress;
				}
				articulation_img.data = src;
				//svg_in_progress = new Promise(resolve => articulation_img.addEventListener("endEvent", resolve, { once: true }));
				await new Promise(resolve => articulation_img.addEventListener("load", resolve));
				if (articulation_img.contentDocument != null) {
					let svg = articulation_img.contentDocument;
					console.log('svg:');console.log(svg);
					console.log(svg.evaluate('count(//animate)', svg).numberValue);
					let svg1 = articulation_img.getSVGDocument();
					console.log('svg1:');console.log(svg1);
					console.log(document.querySelectorAll("svg"));
					if (svg != null) {
						let animation = svg.getElementsByTagName("animate").at(-1);  // last
						if (animation != null)
							animation.addEventListener("endEvent", () => alert("end"));
					}
				}
			}
			function play(src) {
				const url = cache.has(src) ? URL.createObjectURL(cache.get(src)) : src;
				let audio_object = new Audio(url);
				audio_object.addEventListener('loadeddata', () => console.log("Фраза " + src + ": продолжительность аудио " + Math.round(audio_object.duration*1000) + " мс"), { once: true })
				playback_in_progress = new Promise(resolve => {
					audio_object.play();
					audio_object.onended = resolve;
					return cache.has(src) ? url : null;
				});
			}
			async function wait_audio() {  // Usage: await window.wait_audio()
				if (playback_in_progress != null) {
					const url = await playback_in_progress;
					if (url != null)
						URL.revokeObjectURL(url);
					playback_in_progress = null;
				}
			}
			async function press_key() {  // Usage: key_code_string = (await window.key()).code
				return new Promise(resolve => document.addEventListener("keydown", resolve, { once: true }));
			}
			async function wait_key(key) {
				if (key == null || key === "") {
					console.log("Waiting for any key");
					return press_key();
				}
				console.log("Waiting for '" + key + "' key");
				if (!key_subscriptions.has(key))
					key_subscriptions.set(key, new Event("CustomEvent"+key));
				return new Promise(resolve => document.addEventListener("CustomEvent"+key, resolve, { once: true }));
			}
			const params = new Proxy(new URLSearchParams(window.location.search), {
			  get: (searchParams, prop) => searchParams.get(prop),
			});
			// Brython: document.bind("keydown", on_press_key) calls on_press_key(key) where KeyboardEvent is key having the .code field
			if (params.file == null || params.file === '')
				alert(`Добавьте параметр file, равный имени файла для выполнения, в Query string. Например:\n${document.location.href}?file=pharmacy.py`);
			else (async()=>{
				img.src = "spinner.gif";

				// Importing articulation.py:
				code = (await (await fetch(params.file)).text());
				const articulation_imports = code.match(/^from\s+articulation\s+import.*\n/);
				if (articulation_imports != null && articulation_imports.length >= 1)
					code = code.replace(articulation_imports[0], await (await fetch('articulation.py')).text());  // Brython does not respect <base href=...>
				//do {
				//	articulation_imports.shift();
				//	code = code.replace(articulation_imports[0], '');
				//} while articulation_imports.length >= 1);
				
				// Caching data:
				let response = await fetch(params.file + ".cache");
				if (response.status === 200) {
					types = await response.json();
					for (const obj of types) {
						const type = Object.keys(obj)[0];
						const data = obj[type];
						for (const item of data) {
							if (cache.has(item))
								throw `Already have ${item} cached.`;
							if ((response = await fetch(item)).status !== 200)
								throw `Cannot cache {$item}: status=${response}.`
							switch (type) {
								case "svg":
									cache.set(item, `data:image/svg+xml;utf8,${encodeURIComponent((await response.text()).replace(/(\r\n|\n|\r|\t)/gm, ' ').replace('</svg>', `<!-- ${item} --></svg>`))}`);
									break;
								case "wav":
									cache.set(item, await response.blob());
									// TODO: URL.revokeObjectURL(url) after it is not used anymore
									break;
								default:
									throw `Unsupported type in ${params.file + ".cache"}: ${type}.`;
							}
							console.log(`Cached ${item}`);
						}
					}
				}
				
				// Finally showing empty SVG and scrolling the log:
				img.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'/%3E";
				if (i >= 2)
					for (i=1; i < 40; i++)
						console.log(''.padStart(i));
				
				processedcode = `<script type="text/python">from browser import window, aio
async def main():
`  + code.replace(/^/gm, "\t ")
		       .replace(/(\s)slide\(/g,'$1window.slide(')
		       .replace(/(\s)current_slide\(/g,'$1window.current_slide(')
		       .replace(/(\s)play\(/g,'$1window.play(')
		       .replace(/(\s)audio\(/g,'$1window.wait_audio(')
		       .replace(/([^a-zA-Z_0-9])key\(/g,'$1window.wait_key(')
		       .replace(/(\s)articulation\(/g,'$1await window.articulation(')
	+ `
aio.run(main())
`;
				let script = body.insertAdjacentHTML('beforeend', processedcode);
				brython();
			})();
		</script>
	</body>
</html>
